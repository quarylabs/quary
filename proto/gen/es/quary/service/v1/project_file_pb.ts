// @generated by protoc-gen-es v1.9.0 with parameter "target=ts"
// @generated from file quary/service/v1/project_file.proto (package quary.service.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from message quary.service.v1.ProjectFile
 */
export class ProjectFile extends Message<ProjectFile> {
  /**
   * @generated from field: repeated quary.service.v1.ProjectFileSource sources = 1;
   */
  sources: ProjectFileSource[] = [];

  /**
   * @generated from field: repeated quary.service.v1.ProjectFile.Model models = 2;
   */
  models: ProjectFile_Model[] = [];

  /**
   * @generated from field: repeated quary.service.v1.ProjectFile.Snapshot snapshots = 3;
   */
  snapshots: ProjectFile_Snapshot[] = [];

  constructor(data?: PartialMessage<ProjectFile>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quary.service.v1.ProjectFile";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sources", kind: "message", T: ProjectFileSource, repeated: true },
    { no: 2, name: "models", kind: "message", T: ProjectFile_Model, repeated: true },
    { no: 3, name: "snapshots", kind: "message", T: ProjectFile_Snapshot, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProjectFile {
    return new ProjectFile().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProjectFile {
    return new ProjectFile().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProjectFile {
    return new ProjectFile().fromJsonString(jsonString, options);
  }

  static equals(a: ProjectFile | PlainMessage<ProjectFile> | undefined, b: ProjectFile | PlainMessage<ProjectFile> | undefined): boolean {
    return proto3.util.equals(ProjectFile, a, b);
  }
}

/**
 * @generated from message quary.service.v1.ProjectFile.Model
 */
export class ProjectFile_Model extends Message<ProjectFile_Model> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Tags are used to group different parts of the project together. For example, you could tag all models that are
   * related to a specific department with the same tag.
   *
   * @generated from field: repeated string tags = 6;
   */
  tags: string[] = [];

  /**
   * @generated from field: optional string description = 2;
   */
  description?: string;

  /**
   * The materialization of the model, available types are specified by each database.
   *
   * @generated from field: optional string materialization = 4;
   */
  materialization?: string;

  /**
   * @generated from field: repeated quary.service.v1.ModelTest tests = 5;
   */
  tests: ModelTest[] = [];

  /**
   * @generated from field: repeated quary.service.v1.ProjectFileColumn columns = 3;
   */
  columns: ProjectFileColumn[] = [];

  constructor(data?: PartialMessage<ProjectFile_Model>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quary.service.v1.ProjectFile.Model";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "tags", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "materialization", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "tests", kind: "message", T: ModelTest, repeated: true },
    { no: 3, name: "columns", kind: "message", T: ProjectFileColumn, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProjectFile_Model {
    return new ProjectFile_Model().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProjectFile_Model {
    return new ProjectFile_Model().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProjectFile_Model {
    return new ProjectFile_Model().fromJsonString(jsonString, options);
  }

  static equals(a: ProjectFile_Model | PlainMessage<ProjectFile_Model> | undefined, b: ProjectFile_Model | PlainMessage<ProjectFile_Model> | undefined): boolean {
    return proto3.util.equals(ProjectFile_Model, a, b);
  }
}

/**
 * @generated from message quary.service.v1.ProjectFile.Snapshot
 */
export class ProjectFile_Snapshot extends Message<ProjectFile_Snapshot> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Tags are used to group different parts of the project together. For example, you could tag all models that are
   * related to a specific department with the same tag.
   *
   * @generated from field: repeated string tags = 4;
   */
  tags: string[] = [];

  /**
   * @generated from field: optional string description = 5;
   */
  description?: string;

  /**
   * @generated from field: string unique_key = 2;
   */
  uniqueKey = "";

  /**
   * @generated from field: quary.service.v1.ProjectFile.SnapshotStrategy strategy = 3;
   */
  strategy?: ProjectFile_SnapshotStrategy;

  constructor(data?: PartialMessage<ProjectFile_Snapshot>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quary.service.v1.ProjectFile.Snapshot";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "tags", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "unique_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "strategy", kind: "message", T: ProjectFile_SnapshotStrategy },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProjectFile_Snapshot {
    return new ProjectFile_Snapshot().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProjectFile_Snapshot {
    return new ProjectFile_Snapshot().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProjectFile_Snapshot {
    return new ProjectFile_Snapshot().fromJsonString(jsonString, options);
  }

  static equals(a: ProjectFile_Snapshot | PlainMessage<ProjectFile_Snapshot> | undefined, b: ProjectFile_Snapshot | PlainMessage<ProjectFile_Snapshot> | undefined): boolean {
    return proto3.util.equals(ProjectFile_Snapshot, a, b);
  }
}

/**
 * @generated from message quary.service.v1.ProjectFile.SnapshotStrategy
 */
export class ProjectFile_SnapshotStrategy extends Message<ProjectFile_SnapshotStrategy> {
  /**
   * @generated from oneof quary.service.v1.ProjectFile.SnapshotStrategy.strategy_type
   */
  strategyType: {
    /**
     * @generated from field: quary.service.v1.ProjectFile.TimestampStrategy timestamp = 1;
     */
    value: ProjectFile_TimestampStrategy;
    case: "timestamp";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ProjectFile_SnapshotStrategy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quary.service.v1.ProjectFile.SnapshotStrategy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp", kind: "message", T: ProjectFile_TimestampStrategy, oneof: "strategy_type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProjectFile_SnapshotStrategy {
    return new ProjectFile_SnapshotStrategy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProjectFile_SnapshotStrategy {
    return new ProjectFile_SnapshotStrategy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProjectFile_SnapshotStrategy {
    return new ProjectFile_SnapshotStrategy().fromJsonString(jsonString, options);
  }

  static equals(a: ProjectFile_SnapshotStrategy | PlainMessage<ProjectFile_SnapshotStrategy> | undefined, b: ProjectFile_SnapshotStrategy | PlainMessage<ProjectFile_SnapshotStrategy> | undefined): boolean {
    return proto3.util.equals(ProjectFile_SnapshotStrategy, a, b);
  }
}

/**
 * @generated from message quary.service.v1.ProjectFile.TimestampStrategy
 */
export class ProjectFile_TimestampStrategy extends Message<ProjectFile_TimestampStrategy> {
  /**
   * @generated from field: string updated_at = 1;
   */
  updatedAt = "";

  constructor(data?: PartialMessage<ProjectFile_TimestampStrategy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quary.service.v1.ProjectFile.TimestampStrategy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "updated_at", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProjectFile_TimestampStrategy {
    return new ProjectFile_TimestampStrategy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProjectFile_TimestampStrategy {
    return new ProjectFile_TimestampStrategy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProjectFile_TimestampStrategy {
    return new ProjectFile_TimestampStrategy().fromJsonString(jsonString, options);
  }

  static equals(a: ProjectFile_TimestampStrategy | PlainMessage<ProjectFile_TimestampStrategy> | undefined, b: ProjectFile_TimestampStrategy | PlainMessage<ProjectFile_TimestampStrategy> | undefined): boolean {
    return proto3.util.equals(ProjectFile_TimestampStrategy, a, b);
  }
}

/**
 * @generated from message quary.service.v1.ProjectFileSource
 */
export class ProjectFileSource extends Message<ProjectFileSource> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Tags are used to group different parts of the project together. For example, you could tag all sources that are
   * related to a specific department with the same tag.
   *
   * @generated from field: repeated string tags = 6;
   */
  tags: string[] = [];

  /**
   * @generated from field: optional string description = 2;
   */
  description?: string;

  /**
   * The full path of the source table in the database. This is used to reference the table itself. For example:
   * - 'public.users' for where the schema is 'public' and the table is 'users'
   * - 'project_id_123.dataset_id_123.table_id_123' for a BigQuery table
   *
   * @generated from field: string path = 3;
   */
  path = "";

  /**
   * @generated from field: repeated quary.service.v1.ModelTest tests = 5;
   */
  tests: ModelTest[] = [];

  /**
   * @generated from field: repeated quary.service.v1.ProjectFileColumn columns = 4;
   */
  columns: ProjectFileColumn[] = [];

  constructor(data?: PartialMessage<ProjectFileSource>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quary.service.v1.ProjectFileSource";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "tags", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "tests", kind: "message", T: ModelTest, repeated: true },
    { no: 4, name: "columns", kind: "message", T: ProjectFileColumn, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProjectFileSource {
    return new ProjectFileSource().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProjectFileSource {
    return new ProjectFileSource().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProjectFileSource {
    return new ProjectFileSource().fromJsonString(jsonString, options);
  }

  static equals(a: ProjectFileSource | PlainMessage<ProjectFileSource> | undefined, b: ProjectFileSource | PlainMessage<ProjectFileSource> | undefined): boolean {
    return proto3.util.equals(ProjectFileSource, a, b);
  }
}

/**
 * Standard types are:
 * - not_null
 * - unique
 * - 'relationship' which takes into data (model and field)
 *
 * @generated from message quary.service.v1.ProjectFileColumn
 */
export class ProjectFileColumn extends Message<ProjectFileColumn> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: optional string description = 2;
   */
  description?: string;

  /**
   * @generated from field: repeated quary.service.v1.ColumnTest tests = 3;
   */
  tests: ColumnTest[] = [];

  constructor(data?: PartialMessage<ProjectFileColumn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quary.service.v1.ProjectFileColumn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "tests", kind: "message", T: ColumnTest, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProjectFileColumn {
    return new ProjectFileColumn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProjectFileColumn {
    return new ProjectFileColumn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProjectFileColumn {
    return new ProjectFileColumn().fromJsonString(jsonString, options);
  }

  static equals(a: ProjectFileColumn | PlainMessage<ProjectFileColumn> | undefined, b: ProjectFileColumn | PlainMessage<ProjectFileColumn> | undefined): boolean {
    return proto3.util.equals(ProjectFileColumn, a, b);
  }
}

/**
 * @generated from message quary.service.v1.ColumnTest
 */
export class ColumnTest extends Message<ColumnTest> {
  /**
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * @generated from field: map<string, string> info = 2;
   */
  info: { [key: string]: string } = {};

  constructor(data?: PartialMessage<ColumnTest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quary.service.v1.ColumnTest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "info", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ColumnTest {
    return new ColumnTest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ColumnTest {
    return new ColumnTest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ColumnTest {
    return new ColumnTest().fromJsonString(jsonString, options);
  }

  static equals(a: ColumnTest | PlainMessage<ColumnTest> | undefined, b: ColumnTest | PlainMessage<ColumnTest> | undefined): boolean {
    return proto3.util.equals(ColumnTest, a, b);
  }
}

/**
 * @generated from message quary.service.v1.ModelTest
 */
export class ModelTest extends Message<ModelTest> {
  /**
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * @generated from field: map<string, string> info = 2;
   */
  info: { [key: string]: string } = {};

  constructor(data?: PartialMessage<ModelTest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quary.service.v1.ModelTest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "info", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelTest {
    return new ModelTest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelTest {
    return new ModelTest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelTest {
    return new ModelTest().fromJsonString(jsonString, options);
  }

  static equals(a: ModelTest | PlainMessage<ModelTest> | undefined, b: ModelTest | PlainMessage<ModelTest> | undefined): boolean {
    return proto3.util.equals(ModelTest, a, b);
  }
}

