// @generated by protoc-gen-es v1.8.0 with parameter "target=ts"
// @generated from file quary/service/v1/table.proto (package quary.service.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Empty, Message, proto3 } from "@bufbuild/protobuf";
import { ColumnTest } from "./project_file_pb.js";

/**
 * Table is a table in the project that is used to visualise columns, descriptions, and column tests.
 *
 * @generated from message quary.service.v1.Table
 */
export class Table extends Message<Table> {
  /**
   * @generated from oneof quary.service.v1.Table.table_type
   */
  tableType: {
    /**
     * @generated from field: quary.service.v1.Table.PresentInSchema present = 1;
     */
    value: Table_PresentInSchema;
    case: "present";
  } | {
    /**
     * @generated from field: quary.service.v1.Table.NotPresentInSchema not_present = 2;
     */
    value: Table_NotPresentInSchema;
    case: "notPresent";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Table>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quary.service.v1.Table";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "present", kind: "message", T: Table_PresentInSchema, oneof: "table_type" },
    { no: 2, name: "not_present", kind: "message", T: Table_NotPresentInSchema, oneof: "table_type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Table {
    return new Table().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Table {
    return new Table().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Table {
    return new Table().fromJsonString(jsonString, options);
  }

  static equals(a: Table | PlainMessage<Table> | undefined, b: Table | PlainMessage<Table> | undefined): boolean {
    return proto3.util.equals(Table, a, b);
  }
}

/**
 * PresentInSchema is a table that is present in a SQL document and in the YAML definitions.
 * Values are inferred and read from YAML.
 *
 * @generated from message quary.service.v1.Table.PresentInSchema
 */
export class Table_PresentInSchema extends Message<Table_PresentInSchema> {
  /**
   * @generated from field: repeated quary.service.v1.Table.PresentInSchema.PresentRow rows = 1;
   */
  rows: Table_PresentInSchema_PresentRow[] = [];

  constructor(data?: PartialMessage<Table_PresentInSchema>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quary.service.v1.Table.PresentInSchema";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rows", kind: "message", T: Table_PresentInSchema_PresentRow, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Table_PresentInSchema {
    return new Table_PresentInSchema().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Table_PresentInSchema {
    return new Table_PresentInSchema().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Table_PresentInSchema {
    return new Table_PresentInSchema().fromJsonString(jsonString, options);
  }

  static equals(a: Table_PresentInSchema | PlainMessage<Table_PresentInSchema> | undefined, b: Table_PresentInSchema | PlainMessage<Table_PresentInSchema> | undefined): boolean {
    return proto3.util.equals(Table_PresentInSchema, a, b);
  }
}

/**
 * @generated from message quary.service.v1.Table.PresentInSchema.PresentRow
 */
export class Table_PresentInSchema_PresentRow extends Message<Table_PresentInSchema_PresentRow> {
  /**
   * @generated from oneof quary.service.v1.Table.PresentInSchema.PresentRow.row
   */
  row: {
    /**
     * @generated from field: quary.service.v1.Row present_in_sql_and_definitions = 1;
     */
    value: Row;
    case: "presentInSqlAndDefinitions";
  } | {
    /**
     * @generated from field: quary.service.v1.Row missing_in_definitions = 2;
     */
    value: Row;
    case: "missingInDefinitions";
  } | {
    /**
     * @generated from field: quary.service.v1.Row present_in_definitions_but_not_recognisable_in_sql = 3;
     */
    value: Row;
    case: "presentInDefinitionsButNotRecognisableInSql";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Table_PresentInSchema_PresentRow>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quary.service.v1.Table.PresentInSchema.PresentRow";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "present_in_sql_and_definitions", kind: "message", T: Row, oneof: "row" },
    { no: 2, name: "missing_in_definitions", kind: "message", T: Row, oneof: "row" },
    { no: 3, name: "present_in_definitions_but_not_recognisable_in_sql", kind: "message", T: Row, oneof: "row" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Table_PresentInSchema_PresentRow {
    return new Table_PresentInSchema_PresentRow().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Table_PresentInSchema_PresentRow {
    return new Table_PresentInSchema_PresentRow().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Table_PresentInSchema_PresentRow {
    return new Table_PresentInSchema_PresentRow().fromJsonString(jsonString, options);
  }

  static equals(a: Table_PresentInSchema_PresentRow | PlainMessage<Table_PresentInSchema_PresentRow> | undefined, b: Table_PresentInSchema_PresentRow | PlainMessage<Table_PresentInSchema_PresentRow> | undefined): boolean {
    return proto3.util.equals(Table_PresentInSchema_PresentRow, a, b);
  }
}

/**
 * NotPresentInSchema is a table that is present as SQL but not in the YAML definitions. And so all the values
 * are inferred.
 *
 * @generated from message quary.service.v1.Table.NotPresentInSchema
 */
export class Table_NotPresentInSchema extends Message<Table_NotPresentInSchema> {
  /**
   * @generated from field: repeated quary.service.v1.Row rows = 1;
   */
  rows: Row[] = [];

  constructor(data?: PartialMessage<Table_NotPresentInSchema>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quary.service.v1.Table.NotPresentInSchema";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rows", kind: "message", T: Row, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Table_NotPresentInSchema {
    return new Table_NotPresentInSchema().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Table_NotPresentInSchema {
    return new Table_NotPresentInSchema().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Table_NotPresentInSchema {
    return new Table_NotPresentInSchema().fromJsonString(jsonString, options);
  }

  static equals(a: Table_NotPresentInSchema | PlainMessage<Table_NotPresentInSchema> | undefined, b: Table_NotPresentInSchema | PlainMessage<Table_NotPresentInSchema> | undefined): boolean {
    return proto3.util.equals(Table_NotPresentInSchema, a, b);
  }
}

/**
 * Row is a row in the table.
 *
 * @generated from message quary.service.v1.Row
 */
export class Row extends Message<Row> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: repeated quary.service.v1.RowTest tests = 2;
   */
  tests: RowTest[] = [];

  /**
   * @generated from field: quary.service.v1.RowDescription description = 3;
   */
  description?: RowDescription;

  constructor(data?: PartialMessage<Row>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quary.service.v1.Row";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "tests", kind: "message", T: RowTest, repeated: true },
    { no: 3, name: "description", kind: "message", T: RowDescription },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Row {
    return new Row().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Row {
    return new Row().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Row {
    return new Row().fromJsonString(jsonString, options);
  }

  static equals(a: Row | PlainMessage<Row> | undefined, b: Row | PlainMessage<Row> | undefined): boolean {
    return proto3.util.equals(Row, a, b);
  }
}

/**
 * TableTest is a test that is run against a row in a table. It is a oneof because the test can be inferred from the
 * YAML definitions, or it can be present in the SQL document.
 *
 * @generated from message quary.service.v1.RowTest
 */
export class RowTest extends Message<RowTest> {
  /**
   * @generated from oneof quary.service.v1.RowTest.test
   */
  test: {
    /**
     * @generated from field: quary.service.v1.RowTestDetails present_and_not_inferred = 1;
     */
    value: RowTestDetails;
    case: "presentAndNotInferred";
  } | {
    /**
     * @generated from field: quary.service.v1.RowTestDetails present_and_inferred = 2;
     */
    value: RowTestDetails;
    case: "presentAndInferred";
  } | {
    /**
     * @generated from field: quary.service.v1.RowTestDetails not_present_but_inferred = 3;
     */
    value: RowTestDetails;
    case: "notPresentButInferred";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<RowTest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quary.service.v1.RowTest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "present_and_not_inferred", kind: "message", T: RowTestDetails, oneof: "test" },
    { no: 2, name: "present_and_inferred", kind: "message", T: RowTestDetails, oneof: "test" },
    { no: 3, name: "not_present_but_inferred", kind: "message", T: RowTestDetails, oneof: "test" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RowTest {
    return new RowTest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RowTest {
    return new RowTest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RowTest {
    return new RowTest().fromJsonString(jsonString, options);
  }

  static equals(a: RowTest | PlainMessage<RowTest> | undefined, b: RowTest | PlainMessage<RowTest> | undefined): boolean {
    return proto3.util.equals(RowTest, a, b);
  }
}

/**
 * RowTestDetails encapsulates the details of tests associated with row and column data.
 * The 'column_test' field within this structure is specifically used to manage test operations
 * such as deletion and addition. These operations are typically invoked through callbacks.
 *
 * @generated from message quary.service.v1.RowTestDetails
 */
export class RowTestDetails extends Message<RowTestDetails> {
  /**
   * @generated from field: string text = 1;
   */
  text = "";

  /**
   * @generated from field: quary.service.v1.ColumnTest column_test = 2;
   */
  columnTest?: ColumnTest;

  constructor(data?: PartialMessage<RowTestDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quary.service.v1.RowTestDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "column_test", kind: "message", T: ColumnTest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RowTestDetails {
    return new RowTestDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RowTestDetails {
    return new RowTestDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RowTestDetails {
    return new RowTestDetails().fromJsonString(jsonString, options);
  }

  static equals(a: RowTestDetails | PlainMessage<RowTestDetails> | undefined, b: RowTestDetails | PlainMessage<RowTestDetails> | undefined): boolean {
    return proto3.util.equals(RowTestDetails, a, b);
  }
}

/**
 * RowDescription is a description of a row in a table. It is a oneof because the description can be inferred from the
 * YAML definitions and/or it can be present in the SQL document.
 *
 * @generated from message quary.service.v1.RowDescription
 */
export class RowDescription extends Message<RowDescription> {
  /**
   * @generated from oneof quary.service.v1.RowDescription.description
   */
  description: {
    /**
     * @generated from field: string present = 1;
     */
    value: string;
    case: "present";
  } | {
    /**
     * @generated from field: string present_and_inferred_identical = 2;
     */
    value: string;
    case: "presentAndInferredIdentical";
  } | {
    /**
     * @generated from field: quary.service.v1.RowDescription.PresentWithInference present_with_different_inference = 3;
     */
    value: RowDescription_PresentWithInference;
    case: "presentWithDifferentInference";
  } | {
    /**
     * @generated from field: string inferred = 4;
     */
    value: string;
    case: "inferred";
  } | {
    /**
     * @generated from field: google.protobuf.Empty not_present = 5;
     */
    value: Empty;
    case: "notPresent";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<RowDescription>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quary.service.v1.RowDescription";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "present", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "description" },
    { no: 2, name: "present_and_inferred_identical", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "description" },
    { no: 3, name: "present_with_different_inference", kind: "message", T: RowDescription_PresentWithInference, oneof: "description" },
    { no: 4, name: "inferred", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "description" },
    { no: 5, name: "not_present", kind: "message", T: Empty, oneof: "description" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RowDescription {
    return new RowDescription().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RowDescription {
    return new RowDescription().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RowDescription {
    return new RowDescription().fromJsonString(jsonString, options);
  }

  static equals(a: RowDescription | PlainMessage<RowDescription> | undefined, b: RowDescription | PlainMessage<RowDescription> | undefined): boolean {
    return proto3.util.equals(RowDescription, a, b);
  }
}

/**
 * @generated from message quary.service.v1.RowDescription.PresentWithInference
 */
export class RowDescription_PresentWithInference extends Message<RowDescription_PresentWithInference> {
  /**
   * @generated from field: string present = 1;
   */
  present = "";

  /**
   * @generated from field: string inferred = 2;
   */
  inferred = "";

  constructor(data?: PartialMessage<RowDescription_PresentWithInference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quary.service.v1.RowDescription.PresentWithInference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "present", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "inferred", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RowDescription_PresentWithInference {
    return new RowDescription_PresentWithInference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RowDescription_PresentWithInference {
    return new RowDescription_PresentWithInference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RowDescription_PresentWithInference {
    return new RowDescription_PresentWithInference().fromJsonString(jsonString, options);
  }

  static equals(a: RowDescription_PresentWithInference | PlainMessage<RowDescription_PresentWithInference> | undefined, b: RowDescription_PresentWithInference | PlainMessage<RowDescription_PresentWithInference> | undefined): boolean {
    return proto3.util.equals(RowDescription_PresentWithInference, a, b);
  }
}

