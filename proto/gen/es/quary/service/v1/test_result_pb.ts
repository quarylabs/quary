// @generated by protoc-gen-es v1.9.0 with parameter "target=ts"
// @generated from file quary/service/v1/test_result.proto (package quary.service.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Empty, Message, proto3 } from "@bufbuild/protobuf";
import { QueryResult } from "./query_result_pb.js";

/**
 * TestResult is the result of a test serializable so it can be shared
 *
 * @generated from message quary.service.v1.TestResult
 */
export class TestResult extends Message<TestResult> {
  /**
   * @generated from field: string test_name = 1;
   */
  testName = "";

  /**
   * @generated from field: string query = 2;
   */
  query = "";

  /**
   * @generated from oneof quary.service.v1.TestResult.test_result
   */
  testResult: {
    /**
     * @generated from field: quary.service.v1.Passed passed = 3;
     */
    value: Passed;
    case: "passed";
  } | {
    /**
     * @generated from field: quary.service.v1.Failed failed = 4;
     */
    value: Failed;
    case: "failed";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<TestResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quary.service.v1.TestResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "test_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "passed", kind: "message", T: Passed, oneof: "test_result" },
    { no: 4, name: "failed", kind: "message", T: Failed, oneof: "test_result" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestResult {
    return new TestResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestResult {
    return new TestResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestResult {
    return new TestResult().fromJsonString(jsonString, options);
  }

  static equals(a: TestResult | PlainMessage<TestResult> | undefined, b: TestResult | PlainMessage<TestResult> | undefined): boolean {
    return proto3.util.equals(TestResult, a, b);
  }
}

/**
 * @generated from message quary.service.v1.InferredChain
 */
export class InferredChain extends Message<InferredChain> {
  /**
   * @generated from field: repeated string inferred_chain = 1;
   */
  inferredChain: string[] = [];

  constructor(data?: PartialMessage<InferredChain>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quary.service.v1.InferredChain";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inferred_chain", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InferredChain {
    return new InferredChain().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InferredChain {
    return new InferredChain().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InferredChain {
    return new InferredChain().fromJsonString(jsonString, options);
  }

  static equals(a: InferredChain | PlainMessage<InferredChain> | undefined, b: InferredChain | PlainMessage<InferredChain> | undefined): boolean {
    return proto3.util.equals(InferredChain, a, b);
  }
}

/**
 * @generated from message quary.service.v1.InferredChainWithOperation
 */
export class InferredChainWithOperation extends Message<InferredChainWithOperation> {
  /**
   * @generated from field: repeated string inferred_chain = 1;
   */
  inferredChain: string[] = [];

  /**
   * @generated from field: string operation = 2;
   */
  operation = "";

  constructor(data?: PartialMessage<InferredChainWithOperation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quary.service.v1.InferredChainWithOperation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inferred_chain", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "operation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InferredChainWithOperation {
    return new InferredChainWithOperation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InferredChainWithOperation {
    return new InferredChainWithOperation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InferredChainWithOperation {
    return new InferredChainWithOperation().fromJsonString(jsonString, options);
  }

  static equals(a: InferredChainWithOperation | PlainMessage<InferredChainWithOperation> | undefined, b: InferredChainWithOperation | PlainMessage<InferredChainWithOperation> | undefined): boolean {
    return proto3.util.equals(InferredChainWithOperation, a, b);
  }
}

/**
 * @generated from message quary.service.v1.Passed
 */
export class Passed extends Message<Passed> {
  /**
   * @generated from oneof quary.service.v1.Passed.reason
   */
  reason: {
    /**
     * @generated from field: google.protobuf.Empty ran = 1;
     */
    value: Empty;
    case: "ran";
  } | {
    /**
     * @generated from field: quary.service.v1.InferredChain inferred_from_tests = 2;
     */
    value: InferredChain;
    case: "inferredFromTests";
  } | {
    /**
     * inferred_from_logic adds a logic string which explains how it is derived
     *
     * @generated from field: string inferred_from_logic = 3;
     */
    value: string;
    case: "inferredFromLogic";
  } | {
    /**
     * inferred_through_tests_operation infers that the test was inferred and implied through the operation
     *
     * @generated from field: quary.service.v1.InferredChainWithOperation inferred_through_tests_operation = 4;
     */
    value: InferredChainWithOperation;
    case: "inferredThroughTestsOperation";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Passed>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quary.service.v1.Passed";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ran", kind: "message", T: Empty, oneof: "reason" },
    { no: 2, name: "inferred_from_tests", kind: "message", T: InferredChain, oneof: "reason" },
    { no: 3, name: "inferred_from_logic", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "reason" },
    { no: 4, name: "inferred_through_tests_operation", kind: "message", T: InferredChainWithOperation, oneof: "reason" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Passed {
    return new Passed().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Passed {
    return new Passed().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Passed {
    return new Passed().fromJsonString(jsonString, options);
  }

  static equals(a: Passed | PlainMessage<Passed> | undefined, b: Passed | PlainMessage<Passed> | undefined): boolean {
    return proto3.util.equals(Passed, a, b);
  }
}

/**
 * @generated from message quary.service.v1.Failed
 */
export class Failed extends Message<Failed> {
  /**
   * @generated from oneof quary.service.v1.Failed.reason
   */
  reason: {
    /**
     * @generated from field: quary.service.v1.FailedRunResults ran = 1;
     */
    value: FailedRunResults;
    case: "ran";
  } | {
    /**
     * @generated from field: quary.service.v1.InferredChain inferred_from_tests = 2;
     */
    value: InferredChain;
    case: "inferredFromTests";
  } | {
    /**
     * @generated from field: quary.service.v1.InferredChainWithOperation inferred_through_tests_operation = 3;
     */
    value: InferredChainWithOperation;
    case: "inferredThroughTestsOperation";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Failed>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quary.service.v1.Failed";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ran", kind: "message", T: FailedRunResults, oneof: "reason" },
    { no: 2, name: "inferred_from_tests", kind: "message", T: InferredChain, oneof: "reason" },
    { no: 3, name: "inferred_through_tests_operation", kind: "message", T: InferredChainWithOperation, oneof: "reason" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Failed {
    return new Failed().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Failed {
    return new Failed().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Failed {
    return new Failed().fromJsonString(jsonString, options);
  }

  static equals(a: Failed | PlainMessage<Failed> | undefined, b: Failed | PlainMessage<Failed> | undefined): boolean {
    return proto3.util.equals(Failed, a, b);
  }
}

/**
 * @generated from message quary.service.v1.FailedRunResults
 */
export class FailedRunResults extends Message<FailedRunResults> {
  /**
   * @generated from field: quary.service.v1.QueryResult query_result = 1;
   */
  queryResult?: QueryResult;

  constructor(data?: PartialMessage<FailedRunResults>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quary.service.v1.FailedRunResults";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query_result", kind: "message", T: QueryResult },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FailedRunResults {
    return new FailedRunResults().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FailedRunResults {
    return new FailedRunResults().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FailedRunResults {
    return new FailedRunResults().fromJsonString(jsonString, options);
  }

  static equals(a: FailedRunResults | PlainMessage<FailedRunResults> | undefined, b: FailedRunResults | PlainMessage<FailedRunResults> | undefined): boolean {
    return proto3.util.equals(FailedRunResults, a, b);
  }
}

