// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: quary/service/v1/test_result.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Empty } from "../../../google/protobuf/empty";
import { QueryResult } from "./query_result";

export const protobufPackage = "quary.service.v1";

/** TestResult is the result of a test serializable so it can be shared */
export interface TestResult {
  testName: string;
  query: string;
  testResult?: { $case: "passed"; passed: Passed } | { $case: "failed"; failed: Failed } | undefined;
}

export interface InferredChain {
  inferredChain: string[];
}

export interface InferredChainWithOperation {
  inferredChain: string[];
  operation: string;
}

export interface Passed {
  reason?: { $case: "ran"; ran: Empty } | { $case: "inferredFromTests"; inferredFromTests: InferredChain } | //
  /** inferred_from_logic adds a logic string which explains how it is derived */
  { $case: "inferredFromLogic"; inferredFromLogic: string } | //
  /** inferred_through_tests_operation infers that the test was inferred and implied through the operation */
  { $case: "inferredThroughTestsOperation"; inferredThroughTestsOperation: InferredChainWithOperation } | undefined;
}

export interface Failed {
  reason?:
    | { $case: "ran"; ran: FailedRunResults }
    | { $case: "inferredFromTests"; inferredFromTests: InferredChain }
    | { $case: "inferredThroughTestsOperation"; inferredThroughTestsOperation: InferredChainWithOperation }
    | { $case: "failedRunMessage"; failedRunMessage: FailedRunMessage }
    | undefined;
}

export interface FailedRunResults {
  queryResult: QueryResult | undefined;
}

/**
 * FailedRunMessage is a message that contains a message that can be displayed
 * to the user when a test fails. This shoudl be used when the failure is not
 * due to a query result but due to some other reason for example an incorrect
 * query or a query that is not supported.
 */
export interface FailedRunMessage {
  message: string;
}

function createBaseTestResult(): TestResult {
  return { testName: "", query: "", testResult: undefined };
}

export const TestResult: MessageFns<TestResult> = {
  encode(message: TestResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.testName !== "") {
      writer.uint32(10).string(message.testName);
    }
    if (message.query !== "") {
      writer.uint32(18).string(message.query);
    }
    switch (message.testResult?.$case) {
      case "passed":
        Passed.encode(message.testResult.passed, writer.uint32(26).fork()).join();
        break;
      case "failed":
        Failed.encode(message.testResult.failed, writer.uint32(34).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.testName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.testResult = { $case: "passed", passed: Passed.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.testResult = { $case: "failed", failed: Failed.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestResult {
    return {
      testName: isSet(object.testName) ? gt.String(object.testName) : "",
      query: isSet(object.query) ? gt.String(object.query) : "",
      testResult: isSet(object.passed)
        ? { $case: "passed", passed: Passed.fromJSON(object.passed) }
        : isSet(object.failed)
        ? { $case: "failed", failed: Failed.fromJSON(object.failed) }
        : undefined,
    };
  },

  toJSON(message: TestResult): unknown {
    const obj: any = {};
    if (message.testName !== "") {
      obj.testName = message.testName;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.testResult?.$case === "passed") {
      obj.passed = Passed.toJSON(message.testResult.passed);
    } else if (message.testResult?.$case === "failed") {
      obj.failed = Failed.toJSON(message.testResult.failed);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestResult>, I>>(base?: I): TestResult {
    return TestResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestResult>, I>>(object: I): TestResult {
    const message = createBaseTestResult();
    message.testName = object.testName ?? "";
    message.query = object.query ?? "";
    switch (object.testResult?.$case) {
      case "passed": {
        if (object.testResult?.passed !== undefined && object.testResult?.passed !== null) {
          message.testResult = { $case: "passed", passed: Passed.fromPartial(object.testResult.passed) };
        }
        break;
      }
      case "failed": {
        if (object.testResult?.failed !== undefined && object.testResult?.failed !== null) {
          message.testResult = { $case: "failed", failed: Failed.fromPartial(object.testResult.failed) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseInferredChain(): InferredChain {
  return { inferredChain: [] };
}

export const InferredChain: MessageFns<InferredChain> = {
  encode(message: InferredChain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.inferredChain) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InferredChain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInferredChain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inferredChain.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InferredChain {
    return {
      inferredChain: gt.Array.isArray(object?.inferredChain) ? object.inferredChain.map((e: any) => gt.String(e)) : [],
    };
  },

  toJSON(message: InferredChain): unknown {
    const obj: any = {};
    if (message.inferredChain?.length) {
      obj.inferredChain = message.inferredChain;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InferredChain>, I>>(base?: I): InferredChain {
    return InferredChain.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InferredChain>, I>>(object: I): InferredChain {
    const message = createBaseInferredChain();
    message.inferredChain = object.inferredChain?.map((e) => e) || [];
    return message;
  },
};

function createBaseInferredChainWithOperation(): InferredChainWithOperation {
  return { inferredChain: [], operation: "" };
}

export const InferredChainWithOperation: MessageFns<InferredChainWithOperation> = {
  encode(message: InferredChainWithOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.inferredChain) {
      writer.uint32(10).string(v!);
    }
    if (message.operation !== "") {
      writer.uint32(18).string(message.operation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InferredChainWithOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInferredChainWithOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inferredChain.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.operation = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InferredChainWithOperation {
    return {
      inferredChain: gt.Array.isArray(object?.inferredChain) ? object.inferredChain.map((e: any) => gt.String(e)) : [],
      operation: isSet(object.operation) ? gt.String(object.operation) : "",
    };
  },

  toJSON(message: InferredChainWithOperation): unknown {
    const obj: any = {};
    if (message.inferredChain?.length) {
      obj.inferredChain = message.inferredChain;
    }
    if (message.operation !== "") {
      obj.operation = message.operation;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InferredChainWithOperation>, I>>(base?: I): InferredChainWithOperation {
    return InferredChainWithOperation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InferredChainWithOperation>, I>>(object: I): InferredChainWithOperation {
    const message = createBaseInferredChainWithOperation();
    message.inferredChain = object.inferredChain?.map((e) => e) || [];
    message.operation = object.operation ?? "";
    return message;
  },
};

function createBasePassed(): Passed {
  return { reason: undefined };
}

export const Passed: MessageFns<Passed> = {
  encode(message: Passed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.reason?.$case) {
      case "ran":
        Empty.encode(message.reason.ran, writer.uint32(10).fork()).join();
        break;
      case "inferredFromTests":
        InferredChain.encode(message.reason.inferredFromTests, writer.uint32(18).fork()).join();
        break;
      case "inferredFromLogic":
        writer.uint32(26).string(message.reason.inferredFromLogic);
        break;
      case "inferredThroughTestsOperation":
        InferredChainWithOperation.encode(message.reason.inferredThroughTestsOperation, writer.uint32(34).fork())
          .join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Passed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePassed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reason = { $case: "ran", ran: Empty.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = {
            $case: "inferredFromTests",
            inferredFromTests: InferredChain.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = { $case: "inferredFromLogic", inferredFromLogic: reader.string() };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reason = {
            $case: "inferredThroughTestsOperation",
            inferredThroughTestsOperation: InferredChainWithOperation.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Passed {
    return {
      reason: isSet(object.ran)
        ? { $case: "ran", ran: Empty.fromJSON(object.ran) }
        : isSet(object.inferredFromTests)
        ? { $case: "inferredFromTests", inferredFromTests: InferredChain.fromJSON(object.inferredFromTests) }
        : isSet(object.inferredFromLogic)
        ? { $case: "inferredFromLogic", inferredFromLogic: gt.String(object.inferredFromLogic) }
        : isSet(object.inferredThroughTestsOperation)
        ? {
          $case: "inferredThroughTestsOperation",
          inferredThroughTestsOperation: InferredChainWithOperation.fromJSON(object.inferredThroughTestsOperation),
        }
        : undefined,
    };
  },

  toJSON(message: Passed): unknown {
    const obj: any = {};
    if (message.reason?.$case === "ran") {
      obj.ran = Empty.toJSON(message.reason.ran);
    } else if (message.reason?.$case === "inferredFromTests") {
      obj.inferredFromTests = InferredChain.toJSON(message.reason.inferredFromTests);
    } else if (message.reason?.$case === "inferredFromLogic") {
      obj.inferredFromLogic = message.reason.inferredFromLogic;
    } else if (message.reason?.$case === "inferredThroughTestsOperation") {
      obj.inferredThroughTestsOperation = InferredChainWithOperation.toJSON(
        message.reason.inferredThroughTestsOperation,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Passed>, I>>(base?: I): Passed {
    return Passed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Passed>, I>>(object: I): Passed {
    const message = createBasePassed();
    switch (object.reason?.$case) {
      case "ran": {
        if (object.reason?.ran !== undefined && object.reason?.ran !== null) {
          message.reason = { $case: "ran", ran: Empty.fromPartial(object.reason.ran) };
        }
        break;
      }
      case "inferredFromTests": {
        if (object.reason?.inferredFromTests !== undefined && object.reason?.inferredFromTests !== null) {
          message.reason = {
            $case: "inferredFromTests",
            inferredFromTests: InferredChain.fromPartial(object.reason.inferredFromTests),
          };
        }
        break;
      }
      case "inferredFromLogic": {
        if (object.reason?.inferredFromLogic !== undefined && object.reason?.inferredFromLogic !== null) {
          message.reason = { $case: "inferredFromLogic", inferredFromLogic: object.reason.inferredFromLogic };
        }
        break;
      }
      case "inferredThroughTestsOperation": {
        if (
          object.reason?.inferredThroughTestsOperation !== undefined &&
          object.reason?.inferredThroughTestsOperation !== null
        ) {
          message.reason = {
            $case: "inferredThroughTestsOperation",
            inferredThroughTestsOperation: InferredChainWithOperation.fromPartial(
              object.reason.inferredThroughTestsOperation,
            ),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseFailed(): Failed {
  return { reason: undefined };
}

export const Failed: MessageFns<Failed> = {
  encode(message: Failed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.reason?.$case) {
      case "ran":
        FailedRunResults.encode(message.reason.ran, writer.uint32(10).fork()).join();
        break;
      case "inferredFromTests":
        InferredChain.encode(message.reason.inferredFromTests, writer.uint32(18).fork()).join();
        break;
      case "inferredThroughTestsOperation":
        InferredChainWithOperation.encode(message.reason.inferredThroughTestsOperation, writer.uint32(26).fork())
          .join();
        break;
      case "failedRunMessage":
        FailedRunMessage.encode(message.reason.failedRunMessage, writer.uint32(34).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Failed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFailed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reason = { $case: "ran", ran: FailedRunResults.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = {
            $case: "inferredFromTests",
            inferredFromTests: InferredChain.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = {
            $case: "inferredThroughTestsOperation",
            inferredThroughTestsOperation: InferredChainWithOperation.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reason = {
            $case: "failedRunMessage",
            failedRunMessage: FailedRunMessage.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Failed {
    return {
      reason: isSet(object.ran)
        ? { $case: "ran", ran: FailedRunResults.fromJSON(object.ran) }
        : isSet(object.inferredFromTests)
        ? { $case: "inferredFromTests", inferredFromTests: InferredChain.fromJSON(object.inferredFromTests) }
        : isSet(object.inferredThroughTestsOperation)
        ? {
          $case: "inferredThroughTestsOperation",
          inferredThroughTestsOperation: InferredChainWithOperation.fromJSON(object.inferredThroughTestsOperation),
        }
        : isSet(object.failedRunMessage)
        ? { $case: "failedRunMessage", failedRunMessage: FailedRunMessage.fromJSON(object.failedRunMessage) }
        : undefined,
    };
  },

  toJSON(message: Failed): unknown {
    const obj: any = {};
    if (message.reason?.$case === "ran") {
      obj.ran = FailedRunResults.toJSON(message.reason.ran);
    } else if (message.reason?.$case === "inferredFromTests") {
      obj.inferredFromTests = InferredChain.toJSON(message.reason.inferredFromTests);
    } else if (message.reason?.$case === "inferredThroughTestsOperation") {
      obj.inferredThroughTestsOperation = InferredChainWithOperation.toJSON(
        message.reason.inferredThroughTestsOperation,
      );
    } else if (message.reason?.$case === "failedRunMessage") {
      obj.failedRunMessage = FailedRunMessage.toJSON(message.reason.failedRunMessage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Failed>, I>>(base?: I): Failed {
    return Failed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Failed>, I>>(object: I): Failed {
    const message = createBaseFailed();
    switch (object.reason?.$case) {
      case "ran": {
        if (object.reason?.ran !== undefined && object.reason?.ran !== null) {
          message.reason = { $case: "ran", ran: FailedRunResults.fromPartial(object.reason.ran) };
        }
        break;
      }
      case "inferredFromTests": {
        if (object.reason?.inferredFromTests !== undefined && object.reason?.inferredFromTests !== null) {
          message.reason = {
            $case: "inferredFromTests",
            inferredFromTests: InferredChain.fromPartial(object.reason.inferredFromTests),
          };
        }
        break;
      }
      case "inferredThroughTestsOperation": {
        if (
          object.reason?.inferredThroughTestsOperation !== undefined &&
          object.reason?.inferredThroughTestsOperation !== null
        ) {
          message.reason = {
            $case: "inferredThroughTestsOperation",
            inferredThroughTestsOperation: InferredChainWithOperation.fromPartial(
              object.reason.inferredThroughTestsOperation,
            ),
          };
        }
        break;
      }
      case "failedRunMessage": {
        if (object.reason?.failedRunMessage !== undefined && object.reason?.failedRunMessage !== null) {
          message.reason = {
            $case: "failedRunMessage",
            failedRunMessage: FailedRunMessage.fromPartial(object.reason.failedRunMessage),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseFailedRunResults(): FailedRunResults {
  return { queryResult: undefined };
}

export const FailedRunResults: MessageFns<FailedRunResults> = {
  encode(message: FailedRunResults, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.queryResult !== undefined) {
      QueryResult.encode(message.queryResult, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FailedRunResults {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFailedRunResults();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.queryResult = QueryResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FailedRunResults {
    return { queryResult: isSet(object.queryResult) ? QueryResult.fromJSON(object.queryResult) : undefined };
  },

  toJSON(message: FailedRunResults): unknown {
    const obj: any = {};
    if (message.queryResult !== undefined) {
      obj.queryResult = QueryResult.toJSON(message.queryResult);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FailedRunResults>, I>>(base?: I): FailedRunResults {
    return FailedRunResults.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FailedRunResults>, I>>(object: I): FailedRunResults {
    const message = createBaseFailedRunResults();
    message.queryResult = (object.queryResult !== undefined && object.queryResult !== null)
      ? QueryResult.fromPartial(object.queryResult)
      : undefined;
    return message;
  },
};

function createBaseFailedRunMessage(): FailedRunMessage {
  return { message: "" };
}

export const FailedRunMessage: MessageFns<FailedRunMessage> = {
  encode(message: FailedRunMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FailedRunMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFailedRunMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FailedRunMessage {
    return { message: isSet(object.message) ? gt.String(object.message) : "" };
  },

  toJSON(message: FailedRunMessage): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FailedRunMessage>, I>>(base?: I): FailedRunMessage {
    return FailedRunMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FailedRunMessage>, I>>(object: I): FailedRunMessage {
    const message = createBaseFailedRunMessage();
    message.message = object.message ?? "";
    return message;
  },
};

declare const self: any | undefined;
declare const window: any | undefined;
declare const global: any | undefined;
const gt: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
